# 游戏框架

## 绘制

深度：3d是使用深度来处理层级，只需要控制透明和不透明的绘制顺序   2D中深度都是相同的，所以需要知道他们的绘制顺序。


层级顺序，遍历一个ui树，根据深度进行遍历。**存在的问题就是无法修改在全局中的顺序。**

处理方式：渲染从UI树中分离出来。（Ashley）

每个元素单独绘制，存在绘制次数增加的问题（libGdx中有批处理）

## director

cocos中director可以支持多个窗口  

## 绘制优化

使用绘制命令，对绘制进行批处理，并且可以全局排序。

- 每个元素的绘制命令发送给绘制栈
- 绘制栈遍历每个元素之后开始绘制（绘制命令从ui树中分离出去）
- 相同的绘制命令可以一次绘制，较少绘制的次数
- 可以使用不同于ui树的顺序绘制


自动裁剪技术  ，游戏窗口之外的不发送绘制命令。


## 事件分发机制

事件分发机制，根据绘制顺序进行分发（libgdx当前的分发方式）


## 物理引擎

2.x:仅仅可以可以sprite和body关联，只可以改变位置

3.x：仅仅需要设置一个物理属性，就可以对其子元素设置物理刚体

## 数据结构

元素的增删改效率

1.使用缓存Map<key,value>


## Ui树

### 位置和转换

position和瞄点

### 坐标系

坐标系包括本地坐标，世界坐标，坐标系转换

### 世界坐标

左下角00 右上角width hight

### 本地坐标

使用相对坐标系

### 坐标系转换

本地转世界   世界转本地


用来组织一些具有层次结果的数据  树可以用来查找、遍历、修改、排序

### ui树的遍历

渲染系统最重要的职责是遍历UI树中的元素，将每个元素绘制到屏幕上
- 遍历顺序等于渲染顺序
- 模型视图变换矩阵的变换

3D渲染可以是任意顺序渲染，根据深度测试进行正确的绘制，2D的深度是相同的，需要依赖于逻辑深度。


遍历方式：中序遍历


3.x的全局深度，不可以对spritebatchNode单独设置，因为它已经将所有的子元素组织成了一个batchCommand

### 模型视图的矩阵变换

Ui树在遍历的时候需要进行坐标转换，opengl绘制的时候需要知道世界坐标（但是不会那么计算）

Group维护了一个变换矩阵：父类的模型视图变换矩阵右乘当前节点的笨死坐标系中的变换矩阵得到的，最后会将变换矩阵和坐标传递给opengl

### 运行时对象

查找元素使用的是一个int数值，没有使用string，目的是为了加快效率。并且是只能在其子元素中查找。`


## 应用程序架构

游戏从哪里开始   怎样构建场景 更新逻辑

### 生命周期

1.创建一个opengles
2.创建场景


### 窗口尺寸

director控制着opengl的初始化、窗口管理、场景切换、游戏循环。

### 场景管理

一个场景包含一个ui树

### 场景循环

帧开始 --> 用户输入 -->  动画计算 --> 物理模拟 --> 逻辑更新 -->  ui遍历  ---> 绘制
























