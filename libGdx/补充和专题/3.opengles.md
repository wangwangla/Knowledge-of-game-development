# opengl

最早的是通过cpu串行进行计算的，但是为了更高的绘制效率。

一系列的树ui元素构成了游戏的入口，然后每一帧将这些元素显示在屏幕上。

绘制的时候将每个像素的颜色值写入缓冲区

## 绘制系统

2.0中，绘制通过每个元素内部的draw分发绘制，紧密的以来ui树。问题就是无法在不同树中调整顺序

1.绘制逻辑从主循环中分离
2.视口裁剪，在外部的不发送绘制命令
3.批处理


### 绘制过程

3个阶段：
- 绘制命令
- 绘制命令排序
- 绘制


ui树遍历生成绘制命令（每个元素关联一个绘制的命令），执行node分方法的时候将绘制命令给render。特殊绘制命令的时候，绘制到纹理，而不是屏幕。遍历结束了，在从render中开始执行。

绘制命令进行排序，绘制一步才是绘制。

### 绘制命令

它是一种绘制方式的封装，比如一个纹理四个顶点;包含的globalOrder绝定它的顺序。


### 绘制栈

ui元素的绘制命令会被发送到renderQueue中，她会对命令排序，一般的3个数组，小于0  等于0  大于0 


### GroupCommand

一般的不包含绘制命令，它指向一个renderQueue,它不会受到其他的影响，它会将所有的绘制到一个纹理上面的

## Render

主线程遍历ui树，将绘制命令放到绘制栈上，然后在通过绘制栈执行所有的命令（先排序）

render对每一个renderQueue进行排序，【实际都不会进行排序，只对少数的进行排序】

globalOrder仅仅对自己的RenderQueue有用。


### QuadCommand

用来绘制一个或者多个矩阵区域，每个矩阵都是一样纹理部分。比如sprite.

- TextureID
- shader Program
- BlendFunc:混合模式
- Quads：坐标、颜色、纹理坐标


