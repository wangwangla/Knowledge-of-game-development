# 智能体

拥有一定自制能力的智能体，发现障碍，做出反应，并调整动作，或者兔子遇到狐狸，兔子逃跑，
狐狸追逐，中间不需要设计者干预。他们可以自行处理。

## 分为三个环节

- 行动选择：选定母标执行计划。

- 操控：计算轨道数据，操控行为产生操控力，决定智能体的移动。

- 移动：主要表现一个智能体的机械因素
## 交通模型

```java
class MoveEntity extends BaseGameEntity{
	
}
```

移动对象需要的参数

```java
double m_dMass;
double m_dMaxSpeed;
double m_dMaxForce;
double m_dMaxTurenRate;  
```

需要访问不同种类的操纵行为，Vehicle继承于MovingEntity,拥有操控行为类SteeringBehaviors的实例
SteeringBehviors封装不同的操控行为。

```java
class Vehicle extends MovingEntity{
	//GameWorld 
	GameWorld world;   // 包含障碍等
	
	steeringBehaviors steer;
}
```

Vehicle通过操控行为实例操作操控行为。

```java
void update(double delta);
```


## 总结

目前类有 BaseGameEntity / MoveEntity  /   Vehicle   /    SteeringBehviors    /     GameWorld

前三个继承    后两个聚合

## 交通工具物理属性


Vehicle的update方法。

```java
bool update(double delta){
	// 计算合力
	SVector2D steerForce = steer.calculate();
	// 计算操控力
	// 加速度  =  力  /  质量
	SVector2D acceleration = steer / m_dMass;
	//里转化为速度
	m_vVelocity += acceleration * delta;
	// 确保不超过最大速度
	m_vVelocity.Truncate(m_dMaxSpeed);
	//更新位置
	m_vpos += m_vVelocity * delta；
	//如果速度<<值，就更新朝向。
	if(m_vVelocity.LengthSq()>0.000001){
		mvHeading = Vec2DNormalize(m_vVelocity);
		m_side = mvHeading.Perp();
	}
}
```

## 操控行为

#### seek 靠近

可以完成一个到达智能体位置的力。

```java
Vectors2 seek(Vectors2 v){
	//代码不明白含义
}
```

计算预期速度   理想情况下到达的速度  
























































