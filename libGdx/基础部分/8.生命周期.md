## libGDX的生命周期

- 它有明确的生命周期，定义在ApplicationListener中，可以实现方法来实现调用，他可以理解为一个游戏的实例，执行的入口
- 游戏开发中也可以使用ApplicationAdapter，它实现了所有方法。
- 生命周期方法说明
  - create：创建的时候执行一次
  - resize：屏幕发生改变的时候调用一次
  - render：一直都在执行
  - pause： 当游戏界面被新的一个界面覆盖时，该方法将被调用。通常在这里保存暂停时的游戏状态。 
  - resume：重新回来之后的页面
  - dispose：销毁

  ## 方法调用步骤

  Application start--->create--->resize---->render

  进入后台resume   pause
  关闭   close   pause   dispose


  ## 管理scence

替换scence,栈存储起来，还要用，还有就是根据index使用scence

## 游戏循环

开始之后就根据设置好的进行循环

- 用户输入
- 动画计算
- 物理模拟
- 逻辑更新
- ui遍历
- 绘制
- 交换缓冲区


## 实时更新

需要在一定时间来更新一次游戏的状态

### 帧率

绘制速度，每秒的周期。它表示了以什么间隔来进行更新

### scheduler(cococs)

除了自身的系统，还需要提供某种机制更新程序员自定义的游戏对象。

使用回调来实现游戏系统的更新。

- 类型和游戏循环帧率保持不变。      
- 一定间隔的回调

和libGdx的Ations有点像、

## 时间线

有时候我们需要加快和减慢，可以对schedular设置timeScale

实现原理

```
update(){
  dt *= timeScale;
}
```


## 主线程

游戏中并行更新是困难的，受许多因素的影响

### 主线程中执行异步操作

GL相关的方法，必须要在主线程中完成，有时候为了安全，就需要在主线程中完成操作。


### 纹理的异步加载

在scheduler中注册的方法都会在该帧结束的时候被全部执行，对于耗时的就存在问题了。
纹理上传GL的过程就是耗时的步骤，如果多个同时加载完成，同时上传，就会造成卡顿，cocos采样了一个自定义的schedule，它会检查已经加载完成的纹理，每一帧处理一个，知道完成

TextureCache发起一个异步请求，它会注册一个回调，开启一个新的线程来异步加载文件，加载完成放入队列中，每一帧处理一个的进行上传