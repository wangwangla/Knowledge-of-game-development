# spine动画

加载骨骼数据

- name
- bones(骨头)
- slots：槽
- skin:皮肤
  - 默认使用那个皮肤
- events
- animations

## 原始的播放

代码

```java
public class DemoSpine01  extends ApplicationAdapter {
    OrthographicCamera camera;
    PolygonSpriteBatch batch;
    SkeletonRenderer renderer;

    TextureAtlas atlas;
    Skeleton skeleton;
    AnimationState state;

    public void create () {
        camera = new OrthographicCamera();
        batch = new PolygonSpriteBatch(); // Required to render meshes. SpriteBatch can't render meshes.
        renderer = new SkeletonRenderer();
        atlas = new TextureAtlas(Gdx.files.internal("countryleared.atlas"));
        SkeletonJson json = new SkeletonJson(atlas); // This loads skeleton JSON data, which is stateless.
        json.setScale(0.5f); // Load the skeleton at 50% the size it was in Spine.
        SkeletonData skeletonData = json.readSkeletonData(Gdx.files.internal("countryleared.json"));

        skeleton = new Skeleton(skeletonData); // Skeleton holds skeleton state (bone positions, slot attachments, etc).
        skeleton.setPosition(250, 20);

        AnimationStateData stateData = new AnimationStateData(skeletonData); // Defines mixing (crossfading) between animations.

        state = new AnimationState(stateData); // Holds the animation state for a skeleton (current animation, time, etc).
        state.setTimeScale(0.6f); // Slow all animations down to 60% speed.

        // Queue animations on tracks 0 and 1.
        state.setAnimation(0,
                skeletonData.getAnimations().get(0), true);
    }

    public void render () {
        state.update(Gdx.graphics.getDeltaTime()); // Update the animation time.

        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        if (state.apply(skeleton)) // Poses skeleton using current animations. This sets the bones' local SRT.
            skeleton.updateWorldTransform(); // Uses the bones' local SRT to compute their world SRT.

        // Configure the camera, SpriteBatch, and SkeletonRendererDebug.
        camera.update();
        batch.getProjectionMatrix().set(camera.combined);

        batch.begin();
        renderer.draw(batch, skeleton); // Draw the skeleton images.
        batch.end();

    }

    public void resize (int width, int height) {
        camera.setToOrtho(false); // Update camera with new size.
    }

    public void dispose () {
        atlas.dispose();
    }
```



## 使用Actor封装

stage为我们完成了相机，batch我们使用游戏里面的，renderer进行绘制，需要创建

- 继承Actor（需要写入道group中）

- 准备文件数据

  ```java
  String path = "box";
  TextureAtlas atlas = new TextureAtlas(Gdx.files.internal(path+".atlas"));
  SkeletonJson json = new SkeletonJson(atlas);
  SkeletonData skeletonData = json.readSkeletonData(Gdx.files.internal(path+".json"));
  ```

  

- 完整的

  ```java
  public class SpineActor extends Actor {
      SkeletonRenderer renderer = new SkeletonRenderer();
      Skeleton skeleton;
      AnimationState state;
      public SpineActor(){
          String path = "box";
          TextureAtlas atlas = new TextureAtlas(Gdx.files.internal(path+".atlas"));
          SkeletonJson json = new SkeletonJson(atlas);
          SkeletonData skeletonData = json.readSkeletonData(Gdx.files.internal(path+".json"));
          skeleton = new Skeleton(skeletonData); // Skeleton holds skeleton state (bone positions, slot attachments, etc).
          skeleton.setPosition(0, 0);
          AnimationStateData stateData = new AnimationStateData(skeletonData); // Defines mixing (crossfading) between animations.
          state = new AnimationState(stateData); // Holds the animation state for a skeleton (current animation, time, etc).
          state.setTimeScale(0.6f); // Slow all animations down to 60% speed.
          state.setAnimation(0,skeletonData.getAnimations().get(0), true);
      }
  
      @Override
      public void draw(Batch batch, float parentAlpha) {
          super.draw(batch, parentAlpha);
          state.update(Gdx.graphics.getDeltaTime());
          state.apply(skeleton);
          skeleton.updateWorldTransform();
          renderer.draw(batch,skeleton);
      }
  }
  ```

- 加入新功能

  - 位置

    ```java
        @Override
        public void setPosition(float x, float y) {
            super.setPosition(x, y);
            skeleton.setPosition(x,y);
        }
    ```

    

  - 颜色等只需要将actor方法复写就可以了。

## spine加载动画文件

```
public void apply (Skeleton skeleton,   骨骼
float lastTime,  上次應用時間綫的時間
float time,  动画的时间
Array<Event> events, 可以为null
float alpha,    渐变
MixPose pose,    
MixDirection direction);
```

通过动画效果来用代码书写
步骤：

- 加载动画资源，并断点

  <img src="C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20201019182559936.png" alt="image-20201019182559936" style="zoom:50%;" />

- 然后查看执行那个timeline

- 将文件里面的动画数据写入，并继承Action类，复写act方法，执行apply方法。

```java
public class TimelineScaleAction extends Action {
	private float  time;
	private Interpolation interpolation;
	private boolean reverse, began, complete;
	Animation.ActorScaleTimeline timeline;

	public TimelineScaleAction(Animation.ActorScaleTimeline timeline) {
		this.timeline = timeline;
	}


	public boolean act (float delta) {
		if (complete) return true;
		Pool pool = getPool();
		setPool(null); // Ensure this action can't be returned to the pool while executing.
		try {
			if (!began) {
				begin();
				began = true;
			}
			time += delta;
			complete = timeline.apply(target,time,1,1);
			if (complete) end();
			return complete;
		} finally {
			setPool(pool);
		}
	}

	static int binarySearch (float[] values, float target, int step) {
		int low = 0;
		int high = values.length / step - 2;
		if (high == 0) return step;
		int current = high >>> 1;
		while (true) {
			if (values[(current + 1) * step] <= target)
				low = current + 1;
			else
				high = current;
			if (low == high) return (low + 1) * step;
			current = (low + high) >>> 1;
		}
	}

	/** Called the first time {@link #act(float)} is called. This is a good place to query the {@link #actor actor's} starting
	 * state. */
	protected void begin () {
	}

	/** Called the last time {@link #act(float)} is called. */
	protected void end () {
	}


	/** Skips to the end of the transition. */
	public void finish () {
		time = 1000;
	}

	public void restart () {
		time = 0;
		began = false;
		complete = false;
	}


	public void reset () {
		super.reset();
		reverse = false;
		interpolation = null;
	}

	/** Gets the transition time so far. */
	public float getTime () {
		return time;
	}

	/** Sets the transition time so far. */
	public void setTime (float time) {
		this.time = time;
	}

	public Interpolation getInterpolation () {
		return interpolation;
	}

	public void setInterpolation (Interpolation interpolation) {
		this.interpolation = interpolation;
	}

	public boolean isReverse () {
		return reverse;
	}

	/** When true, the action's progress will go from 100% to 0%. */
	public void setReverse (boolean reverse) {
		this.reverse = reverse;
	}
}

```

- 使用

```java
Animation.ActorScaleTimeline timeline = new Animation.ActorScaleTimeline(frameCount);
timeline.setFrame(0, 0, 0.175F,0.175F);
timeline.setCurve(0, 0F, 0, 0.75F, 1);
timeline.setFrame(1, 0.2F, 1.205F, 1.205F);
timeline.setCurve(1, 0.25F, 0, 0.75F, 1);
timeline.setFrame(2, 0.2F, 1.205F, 1.205F);
newTip.addAction(new TimelineScaleAction(actorScaleTimeline));
```







spine封装之后，就可以看作是简单的actor使用了，可以对其进行相应的操作。



























